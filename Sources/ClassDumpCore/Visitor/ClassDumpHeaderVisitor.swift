import Foundation

/// A visitor that generates class dump output with headers and file info.
///
/// This extends TextClassDumpVisitor to add header comments showing file information,
/// architecture, version info, and other metadata at the beginning of the output.
public final class ClassDumpHeaderVisitor: TextClassDumpVisitor, @unchecked Sendable {
  /// Header string to prepend to output
  public var headerString: String = ""

  /// Structure definitions to include
  public var structureDefinitions: String = ""

  /// Whether to write to stdout when done
  public var writeToStdoutOnCompletion: Bool = true

  public override init(options: ClassDumpVisitorOptions = .init()) {
    super.init(options: options)
  }

  // MARK: - Lifecycle

  public override func willBeginVisiting() {
    super.willBeginVisiting()

    append(headerString)

    if options.shouldShowStructureSection && !structureDefinitions.isEmpty {
      append(structureDefinitions)
    }
  }

  public override func didEndVisiting() {
    super.didEndVisiting()

    if writeToStdoutOnCompletion {
      writeResultToStandardOutput()
    }
  }

  // MARK: - Processor Visits

  public override func visitProcessor(_ processor: ObjCProcessorInfo) {
    let file = processor.machOFile

    append("#pragma mark -\n\n")
    append("//\n")
    append("// File: \(file.filename)\n")

    if let uuid = file.uuid {
      append("// UUID: \(uuid.uuidString)\n")
    }

    append("//\n")
    append("//                           Arch: \(file.archName)\n")

    // Dylib info
    if file.filetype == 6, let dylib = file.dylibIdentifier {  // MH_DYLIB = 6
      append("//                Current version: \(dylib.currentVersion)\n")
      append("//          Compatibility version: \(dylib.compatibilityVersion)\n")
    }

    // Version info
    if let sourceVersion = file.sourceVersion {
      append("//                 Source version: \(sourceVersion)\n")
    }

    if let buildVersion = file.buildVersion {
      append("//                  Build version: \(buildVersion)\n")
      if let tools = file.buildTools, !tools.isEmpty {
        let toolsStr = tools.joined(separator: "\n                                   ")
        append("//                          Tools: \(toolsStr)\n")
      }
    }

    if let macOS = file.minMacOSVersion {
      append("//       Minimum Mac OS X version: \(macOS)\n")
      if let sdk = file.sdkVersion {
        append("//                    SDK version: \(sdk)\n")
      }
    }

    if let iOS = file.minIOSVersion {
      append("//            Minimum iOS version: \(iOS)\n")
      if let sdk = file.sdkVersion {
        append("//                    SDK version: \(sdk)\n")
      }
    }

    // GC status
    if let gcStatus = processor.garbageCollectionStatus {
      append("//\n")
      append("// Objective-C Garbage Collection: \(gcStatus)\n")
    }

    // Dyld environment
    if !file.dyldEnvironment.isEmpty {
      append("//\n")
      for (index, env) in file.dyldEnvironment.enumerated() {
        if index == 0 {
          append("//               dyld environment: \(env)\n")
        } else {
          append("//                                 \(env)\n")
        }
      }
    }

    // Run paths
    if !file.runPaths.isEmpty {
      append("//\n")
      for runPath in file.runPaths {
        append("//                       Run path: \(runPath.path)\n")
        append("//                               = \(runPath.resolved)\n")
      }
    }

    // Encryption info
    if file.isEncrypted {
      append("//         This file is encrypted:\n")
    } else if file.hasProtectedSegments {
      if file.canDecryptAllSegments {
        append("//\n")
        append("//     This file has protected segments, decrypting.\n")
      } else {
        append("//\n")
        append("//     This file has protected segments that can't be decrypted.\n")
      }
    }

    append("//\n\n")

    if !processor.hasObjectiveCRuntimeInfo {
      append("//\n")
      append("// This file does not contain any Objective-C runtime information.\n")
      append("//\n")
    }
  }
}

// MARK: - Header Generation

extension ClassDumpHeaderVisitor {
  /// Generate a standard header comment.
  public static func generateHeader(
    generatedBy: String = "class-dump",
    version: String? = nil
  ) -> String {
    var header = "//\n"
    header += "//     Generated by \(generatedBy)"
    if let ver = version {
      header += " \(ver)"
    }
    header += "\n"
    header += "//\n"
    header += "//  Copyright (C) 1997-2019 Steve Nygard.\n"
    header += "//\n\n"
    return header
  }
}
